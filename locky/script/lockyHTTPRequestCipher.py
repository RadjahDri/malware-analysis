#!/usr/bin/python3.6

#
# Ciphering Protocol to Locky HTTP Request to C&C
# Author: Adrien Coueron
#

import sys, hashlib

def ror(n, dec):
	n &= 0xFFFFFFFF
	return ((n >> dec) | (n << (32-dec))) & 0xFFFFFFFF

def rol(n, dec):
	return ((n << dec) | (n >> (32-dec))) & 0xFFFFFFFF

def hashMD5(strData):
	m = hashlib.new('md5')
	m.update(strData)
	return m.digest()

def encryptHexa(plaintext):
	return "".join(list(map(lambda x:x[2:],map(hex,encrypt(plaintext)))))

def encryptAscii(plaintext):
	return encrypt(plaintext.encode('utf-8')).decode('utf-8')

def encrypt(dataText):
	integrityHash = hashMD5(dataText)
	data = bytearray(integrityHash+dataText)
	key = 0xCD43EF19
	for i in range(len(data)):
		currentChar = data[i]
		data[i] = (((ror(key, 5) & 0xFF) - rol(i, 0xD) & 0xFF) & 0xFF) ^ (data[i] & 0xFF)
		key = (rol(currentChar, i%32) + ror(key,1)) ^ (ror(i, 23) + 0x53702F68)
	return data

def decryptAscii(cipher):
	return decrypt(cipher).decode('utf-8')

def decrypt(cipher):
	key = 0xCD43EF19
	plaintext = bytearray()
	for i, e in enumerate(cipher):
		currentChar = cipher[i]
		plaintext.append((((ror(key, 5) & 0xFF) - rol(i, 0xD) & 0xFF) & 0xFF) ^ currentChar)
		key = (rol(plaintext[i], i%32) + ror(key,1)) ^ (ror(i, 23) + 0x53702F68)
	calculatedHash = hashMD5(plaintext[16:])
	if(plaintext[:16] != calculatedHash):
		print("Integrity error:\nchecksum send: {}\nChecksum calculated:Â {}".format(plaintext[:16], calculatedHash))
		print(str(ord(plaintext[0]))+'\t'+str(hashMD5(plaintext[16:])[0]))
	return plaintext[16:]


if __name__=='__main__':
	if(len(sys.argv) != 2):
		print("Usage: "+sys.argv[0]+" plaintext")
		exit(0)

	plaintext = sys.argv[1]

	print("=== Plaintext ===")
	print(plaintext)
	plaintext = plaintext.encode('utf-8')
	print("=== Hexa(cipher(Plaintext)) ===")
	print(encryptHexa(plaintext))
	print("=== Decrypt(cipher(Plaintext)) ===")
	print(decryptAscii(encrypt(plaintext)))

