#!/usr/bin/python3.6

#
# Ciphering Protocol to Locky HTTP Response to C&C
# Author: Adrien Coueron
#

import sys,hashlib

def ror(n, dec):
	n &= 0xFFFFFFFF
	return ((n >> dec) | (n << (32-dec))) & 0xFFFFFFFF

def rol(n, dec):
	return ((n << dec) | (n >> (32-dec))) & 0xFFFFFFFF

def hashMD5(strData):
	m = hashlib.new('md5')
	m.update(strData)
	return m.digest()

def decryptAscii(cipherData):
	return decrypt(cipherData).decode('utf-8')

def decrypt(data):
	plaintext = bytearray()
	key = 0xAFF49754;
	for i in range(len(data)):
		newChar = (((data[i] - i) & 0xFF) - rol(key, 3)) & 0xFF
		plaintext.append(newChar)
		key = (key + (ror(newChar, 11) ^ rol(key, 5) ^ i) - 0x47CB0D2F) & 0xFFFFFFFF
	calculatedHash = hashMD5(plaintext[16:])
	if(plaintext[:16] != calculatedHash):
		print("Integrity error:\nchecksum send: {}\nChecksum calculated:Â {}".format(plaintext[:16], calculatedHash))
	return plaintext[16:]

def encryptAscii(dataStr):
	return encrypt(dataStr).decode('utf-8')

def encrypt(dataStr):
	integrityHash = hashMD5(dataStr)
	data = integrityHash+dataStr
	dataOut = bytearray()
	key = 0xAFF49754;
	for i in range(len(data)):
		oldChar = data[i]
		dataOut.append((((data[i] + rol(key, 3)) & 0xFF) + i)& 0xFF)
		key = (key + (ror(oldChar, 11) ^ rol(key, 5) ^ i) - 0x47CB0D2F) & 0xFFFFFFFF
	return dataOut

def encryptHexa(dataStr):
	return "".join(map(lambda x:x[2:], map(hex, encrypt(dataStr))))


if __name__=='__main__':
	if(len(sys.argv) != 2):
		print("Usage: "+sys.argv[0]+" plaintext")
		exit(0)

	ciphertext = sys.argv[1]
	print("=== ciphertext ===")
	print(ciphertext)
	ciphertext = ciphertext.encode('utf-8')
	print("=== EncryptHexa(ciphertext) ===")
	print(encryptHexa(ciphertext))
	print("=== Decrypt(Encrypt(ciphertext)) ===")
	print(decryptAscii(encrypt(ciphertext)))
